const cds = require ('../..'), minified = csn => cds.linked(csn).minified()
const cdsc = require ('../cdsc')
const {unfold_ddl} = cds.alpha_localized
const EXT_BACK_PACK = 'extensions__'

function cds_compile_to_sql_ (csn,_o) {
  const o = cdsc._options.for.sql(_o) //> used twice below...
  const all = cdsc.to.sql (minified(csn),o)
  const sql = unfold_ddl (all.map (each => each
    .replace(/^-- .+\n/,'')  //> strip comments
  ), csn, o)
  if (o.as === 'str') return `\n${sql.join('\n\n')}\n`
  return sql
}

function cds_compile_to_sql (csn,_o) {
  const defs = cds.linked(csn).definitions
  for (let each in defs) {
    const d = defs[each], q = d.query
    // q may have SET instead of SELECT
    if (q && q.SELECT && q.SELECT.columns && _is_extensible(d)) _add_extensions2 (q.SELECT.columns)
  }
  function _is_extensible (d) {
    if(!d || !d.elements) return false
    if (EXT_BACK_PACK in d.elements) return true
    else return _is_extensible (d.__proto__)
  }
  function _add_extensions2 (cols) {
    if (cols.some(({ref}) => ref && ref[0] === EXT_BACK_PACK)) return
    cols.push({ref:[EXT_BACK_PACK]})
  }
  const ddl = cds_compile_to_sql_ (csn,_o)
  return ddl
}


function cds_compile_to_hdbtable (csn,o) {
  const all = cdsc.to.hdi (minified(csn),o)
  return _2many(all)
}


function cds_compile_to_hdbcds (csn,o) {
  const all = cdsc.to.hdbcds (minified(csn),o)
  const constructFileName = (fileName) => {
    const identifier = fileName.split('.');
    const suffix = identifier.pop();
    return identifier.join('_').concat(`.${suffix}`);
  }
  return _2many(all, constructFileName);
}

function* _2many (all,_file=f=>f) {
  for (let file in all) yield [
    all[file].replace(/^(\/\/|--) generated by .+\n/,''),
    { file:_file(file) }
  ]
}

module.exports = Object.assign (cds_compile_to_sql, {
  hdbcds: cds_compile_to_hdbcds,
  hdbtable: cds_compile_to_hdbtable,
})
